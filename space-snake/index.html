<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Snake</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0e27;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
        }

        #gameCanvas {
            border: 2px solid #00d9ff;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(0, 217, 255, 0.3);
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            color: #fff;
            font-size: 18px;
            text-shadow: 0 0 10px rgba(0, 217, 255, 0.8);
            pointer-events: none;
        }

        .ui-section {
            background: rgba(10, 14, 39, 0.7);
            padding: 8px 15px;
            border-radius: 5px;
            border: 1px solid rgba(0, 217, 255, 0.3);
        }

        #scoreDisplay {
            font-size: 24px;
            font-weight: bold;
        }

        #levelDisplay {
            text-align: center;
            font-size: 20px;
        }

        #comboDisplay {
            text-align: right;
        }

        #comboMultiplier {
            font-size: 28px;
            font-weight: bold;
            transition: color 0.3s;
        }

        #comboTimerBar {
            width: 100px;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }

        #comboTimerFill {
            height: 100%;
            background: linear-gradient(90deg, #00d9ff, #00ff88);
            transition: width 0.1s linear;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(10, 14, 39, 0.9);
            color: #fff;
            text-align: center;
            border-radius: 8px;
        }

        #overlay.hidden {
            display: none;
        }

        #overlay h1 {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #00d9ff;
            background: linear-gradient(135deg, #00d9ff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        #overlay p {
            font-size: 18px;
            margin: 10px 0;
            color: #aaa;
        }

        #overlay .highlight {
            color: #00d9ff;
            font-size: 24px;
        }

        #overlay .instructions {
            margin-top: 30px;
            padding: 20px;
            background: rgba(0, 217, 255, 0.1);
            border-radius: 10px;
            border: 1px solid rgba(0, 217, 255, 0.3);
        }

        #overlay .instructions h3 {
            color: #00d9ff;
            margin-bottom: 15px;
        }

        #overlay .instructions p {
            font-size: 14px;
            margin: 5px 0;
        }

        .prompt {
            margin-top: 30px;
            font-size: 20px;
            color: #ffd700;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        #highScoreDisplay {
            color: #ffd700;
            font-size: 20px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="ui">
            <div class="ui-section" id="scoreSection">
                <div id="scoreDisplay">0</div>
                <div id="highScoreDisplay">HIGH: 0</div>
            </div>
            <div class="ui-section" id="levelDisplay">LEVEL 1</div>
            <div class="ui-section" id="comboDisplay">
                <div id="comboMultiplier">1x</div>
                <div id="comboTimerBar">
                    <div id="comboTimerFill"></div>
                </div>
            </div>
        </div>
        <div id="overlay">
            <h1>SPACE SNAKE</h1>
            <p id="highScoreOverlay" class="highlight">HIGH SCORE: 0</p>
            <div class="instructions">
                <h3>HOW TO PLAY</h3>
                <p>Use ARROW KEYS or WASD to move</p>
                <p>Eat stars to grow and score points</p>
                <p>Use PORTALS to teleport across the map</p>
                <p>Build COMBOS by eating quickly!</p>
                <p>SPACE to pause | Avoid walls and obstacles</p>
            </div>
            <p class="prompt">Press ENTER to Start</p>
        </div>
    </div>

    <script>
        // Game Configuration
        const CONFIG = {
            GRID_SIZE: 20,
            CELL_SIZE: 30,
            BASE_SPEED: 150,
            COMBO_TIMEOUT: 3000,
            MAX_COMBO: 5,
            BASE_POINTS: 10,
            FOOD_PER_LEVEL: 5
        };

        // Game State
        const GameState = {
            START: 'start',
            PLAYING: 'playing',
            PAUSED: 'paused',
            GAME_OVER: 'gameover'
        };

        // Direction vectors
        const Direction = {
            UP: { x: 0, y: -1 },
            DOWN: { x: 0, y: 1 },
            LEFT: { x: -1, y: 0 },
            RIGHT: { x: 1, y: 0 }
        };

        // Portal colors
        const PORTAL_COLORS = [
            ['#00ffff', '#ff00ff'],
            ['#ffff00', '#00ff00'],
            ['#ff6600', '#6600ff']
        ];

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = CONFIG.GRID_SIZE * CONFIG.CELL_SIZE;
                this.canvas.height = CONFIG.GRID_SIZE * CONFIG.CELL_SIZE;

                this.overlay = document.getElementById('overlay');
                this.scoreDisplay = document.getElementById('scoreDisplay');
                this.highScoreDisplay = document.getElementById('highScoreDisplay');
                this.highScoreOverlay = document.getElementById('highScoreOverlay');
                this.levelDisplay = document.getElementById('levelDisplay');
                this.comboMultiplier = document.getElementById('comboMultiplier');
                this.comboTimerFill = document.getElementById('comboTimerFill');

                this.highScore = parseInt(localStorage.getItem('snakeHighScore')) || 0;
                this.updateHighScoreDisplay();

                this.stars = this.generateStars(100);
                this.shootingStars = [];

                this.state = GameState.START;
                this.init();
                this.setupControls();
                this.gameLoop();
            }

            init() {
                this.snake = [{ x: 10, y: 10 }];
                this.direction = Direction.RIGHT;
                this.nextDirection = Direction.RIGHT;
                this.score = 0;
                this.level = 1;
                this.foodEaten = 0;
                this.combo = 1;
                this.comboTimer = 0;
                this.lastMoveTime = 0;
                this.particles = [];
                this.screenShake = 0;
                this.screenFlash = 0;

                this.generateLevel();
                this.spawnFood();
                this.updateUI();
            }

            generateStars(count) {
                const stars = [];
                for (let i = 0; i < count; i++) {
                    stars.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        size: Math.random() * 2 + 0.5,
                        brightness: Math.random() * 0.5 + 0.5,
                        twinkleSpeed: Math.random() * 0.02 + 0.01
                    });
                }
                return stars;
            }

            generateLevel() {
                this.obstacles = [];
                this.portals = [];

                const portalCount = this.level <= 2 ? 1 : this.level <= 5 ? Math.floor(Math.random() * 2) + 1 : Math.floor(Math.random() * 2) + 2;

                // Generate portals
                for (let i = 0; i < Math.min(portalCount, 3); i++) {
                    let attempts = 0;
                    while (attempts < 50) {
                        const portal1 = this.getRandomPosition(5);
                        const portal2 = this.getRandomPosition(5);

                        if (portal1 && portal2 &&
                            Math.abs(portal1.x - portal2.x) + Math.abs(portal1.y - portal2.y) > 8) {
                            this.portals.push({
                                a: portal1,
                                b: portal2,
                                color: PORTAL_COLORS[i],
                                rotation: 0
                            });
                            break;
                        }
                        attempts++;
                    }
                }

                // Generate obstacles based on level
                if (this.level >= 3) {
                    const obstacleCount = this.level <= 5 ?
                        Math.floor(Math.random() * 3) + 2 :
                        this.level <= 10 ?
                        Math.floor(Math.random() * 5) + 4 :
                        Math.floor(Math.random() * 8) + 8;

                    for (let i = 0; i < obstacleCount; i++) {
                        this.generateObstacle();
                    }
                }
            }

            generateObstacle() {
                const length = this.level <= 5 ?
                    Math.floor(Math.random() * 3) + 2 :
                    Math.floor(Math.random() * 4) + 3;

                let attempts = 0;
                while (attempts < 30) {
                    const start = this.getRandomPosition(6);
                    if (!start) {
                        attempts++;
                        continue;
                    }

                    const obstacle = [{ ...start }];
                    const dirs = [Direction.UP, Direction.DOWN, Direction.LEFT, Direction.RIGHT];
                    let currentPos = { ...start };
                    let lastDir = dirs[Math.floor(Math.random() * 4)];

                    for (let i = 1; i < length; i++) {
                        // Occasionally change direction for L-shapes
                        if (this.level >= 6 && Math.random() < 0.3) {
                            lastDir = dirs[Math.floor(Math.random() * 4)];
                        }

                        const newPos = {
                            x: currentPos.x + lastDir.x,
                            y: currentPos.y + lastDir.y
                        };

                        if (this.isValidObstaclePosition(newPos)) {
                            obstacle.push(newPos);
                            currentPos = newPos;
                        }
                    }

                    if (obstacle.length >= 2) {
                        this.obstacles.push(obstacle);
                        return;
                    }
                    attempts++;
                }
            }

            getRandomPosition(minDistFromSnake = 0) {
                let attempts = 0;
                while (attempts < 100) {
                    const pos = {
                        x: Math.floor(Math.random() * (CONFIG.GRID_SIZE - 2)) + 1,
                        y: Math.floor(Math.random() * (CONFIG.GRID_SIZE - 2)) + 1
                    };

                    const distFromSnake = Math.abs(pos.x - this.snake[0].x) + Math.abs(pos.y - this.snake[0].y);

                    if (distFromSnake >= minDistFromSnake && !this.isOccupied(pos)) {
                        return pos;
                    }
                    attempts++;
                }
                return null;
            }

            isValidObstaclePosition(pos) {
                return pos.x > 0 && pos.x < CONFIG.GRID_SIZE - 1 &&
                       pos.y > 0 && pos.y < CONFIG.GRID_SIZE - 1 &&
                       !this.isOccupied(pos);
            }

            isOccupied(pos) {
                // Check snake
                if (this.snake.some(s => s.x === pos.x && s.y === pos.y)) return true;

                // Check obstacles
                for (const obstacle of this.obstacles) {
                    if (obstacle.some(o => o.x === pos.x && o.y === pos.y)) return true;
                }

                // Check portals
                for (const portal of this.portals) {
                    if ((portal.a.x === pos.x && portal.a.y === pos.y) ||
                        (portal.b.x === pos.x && portal.b.y === pos.y)) return true;
                }

                // Check food
                if (this.food && this.food.x === pos.x && this.food.y === pos.y) return true;

                return false;
            }

            spawnFood() {
                this.food = this.getRandomPosition(0);
                this.foodPulse = 0;
            }

            setupControls() {
                document.addEventListener('keydown', (e) => {
                    if (this.state === GameState.START || this.state === GameState.GAME_OVER) {
                        if (e.key === 'Enter') {
                            this.startGame();
                        }
                        return;
                    }

                    if (this.state === GameState.PLAYING || this.state === GameState.PAUSED) {
                        if (e.key === ' ') {
                            this.togglePause();
                            return;
                        }
                    }

                    if (this.state !== GameState.PLAYING) return;

                    const keyMap = {
                        'ArrowUp': Direction.UP, 'w': Direction.UP, 'W': Direction.UP,
                        'ArrowDown': Direction.DOWN, 's': Direction.DOWN, 'S': Direction.DOWN,
                        'ArrowLeft': Direction.LEFT, 'a': Direction.LEFT, 'A': Direction.LEFT,
                        'ArrowRight': Direction.RIGHT, 'd': Direction.RIGHT, 'D': Direction.RIGHT
                    };

                    const newDir = keyMap[e.key];
                    if (newDir) {
                        // Prevent reversing
                        if (newDir.x !== -this.direction.x || newDir.y !== -this.direction.y) {
                            this.nextDirection = newDir;
                        }
                    }
                });
            }

            startGame() {
                this.init();
                this.state = GameState.PLAYING;
                this.overlay.classList.add('hidden');
            }

            togglePause() {
                if (this.state === GameState.PLAYING) {
                    this.state = GameState.PAUSED;
                } else if (this.state === GameState.PAUSED) {
                    this.state = GameState.PLAYING;
                }
            }

            gameOver() {
                this.state = GameState.GAME_OVER;
                this.screenShake = 20;

                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('snakeHighScore', this.highScore);
                    this.updateHighScoreDisplay();
                }

                setTimeout(() => {
                    this.overlay.querySelector('h1').textContent = 'GAME OVER';
                    this.overlay.querySelector('.highlight').textContent = `SCORE: ${this.score}`;
                    this.overlay.querySelector('.instructions').innerHTML = `
                        <h3>STATS</h3>
                        <p>Level Reached: ${this.level}</p>
                        <p>Food Eaten: ${this.foodEaten}</p>
                        <p>High Score: ${this.highScore}</p>
                    `;
                    this.overlay.querySelector('.prompt').textContent = 'Press ENTER to Restart';
                    this.overlay.classList.remove('hidden');
                }, 500);
            }

            update(deltaTime) {
                if (this.state !== GameState.PLAYING) return;

                // Update combo timer
                if (this.combo > 1) {
                    this.comboTimer -= deltaTime;
                    if (this.comboTimer <= 0) {
                        this.combo = 1;
                        this.updateUI();
                    }
                }

                // Calculate current speed
                const speedMultiplier = Math.min(1 + (this.level - 1) * 0.05, 2);
                const currentSpeed = CONFIG.BASE_SPEED / speedMultiplier;

                // Move snake
                this.lastMoveTime += deltaTime;
                if (this.lastMoveTime >= currentSpeed) {
                    this.lastMoveTime = 0;
                    this.moveSnake();
                }

                // Update particles
                this.particles = this.particles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= deltaTime / 1000;
                    p.vy += 0.1; // Gravity
                    return p.life > 0;
                });

                // Update portal rotation
                this.portals.forEach(portal => {
                    portal.rotation += 0.05;
                });

                // Update food pulse
                this.foodPulse += 0.1;

                // Random shooting stars
                if (Math.random() < 0.005) {
                    this.shootingStars.push({
                        x: Math.random() * this.canvas.width,
                        y: 0,
                        vx: (Math.random() - 0.5) * 3,
                        vy: Math.random() * 5 + 3,
                        life: 1
                    });
                }

                // Update shooting stars
                this.shootingStars = this.shootingStars.filter(s => {
                    s.x += s.vx;
                    s.y += s.vy;
                    s.life -= 0.02;
                    return s.life > 0 && s.y < this.canvas.height;
                });
            }

            moveSnake() {
                this.direction = this.nextDirection;

                const head = { ...this.snake[0] };
                head.x += this.direction.x;
                head.y += this.direction.y;

                // Check portal teleportation
                for (const portal of this.portals) {
                    if (head.x === portal.a.x && head.y === portal.a.y) {
                        head.x = portal.b.x + this.direction.x;
                        head.y = portal.b.y + this.direction.y;
                        this.createParticles(portal.a.x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2,
                                           portal.a.y * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2,
                                           portal.color[0], 10);
                        break;
                    }
                    if (head.x === portal.b.x && head.y === portal.b.y) {
                        head.x = portal.a.x + this.direction.x;
                        head.y = portal.a.y + this.direction.y;
                        this.createParticles(portal.b.x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2,
                                           portal.b.y * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2,
                                           portal.color[1], 10);
                        break;
                    }
                }

                // Check wall collision
                if (head.x < 0 || head.x >= CONFIG.GRID_SIZE ||
                    head.y < 0 || head.y >= CONFIG.GRID_SIZE) {
                    this.gameOver();
                    return;
                }

                // Check self collision
                if (this.snake.some(s => s.x === head.x && s.y === head.y)) {
                    this.gameOver();
                    return;
                }

                // Check obstacle collision
                for (const obstacle of this.obstacles) {
                    if (obstacle.some(o => o.x === head.x && o.y === head.y)) {
                        this.gameOver();
                        return;
                    }
                }

                this.snake.unshift(head);

                // Check food collision
                if (this.food && head.x === this.food.x && head.y === this.food.y) {
                    this.eatFood();
                } else {
                    this.snake.pop();
                }
            }

            eatFood() {
                // Update combo
                if (this.comboTimer > 0) {
                    this.combo = Math.min(this.combo + 1, CONFIG.MAX_COMBO);
                    if (this.combo === 3 || this.combo === 5) {
                        this.screenFlash = 10;
                    }
                } else {
                    this.combo = 1;
                }
                this.comboTimer = CONFIG.COMBO_TIMEOUT;

                // Calculate score
                const points = CONFIG.BASE_POINTS * this.combo;
                this.score += points;
                this.foodEaten++;

                // Create particles
                this.createParticles(
                    this.food.x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2,
                    this.food.y * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2,
                    '#ffd700',
                    10 + this.combo * 5
                );

                // Check level up
                if (this.foodEaten % CONFIG.FOOD_PER_LEVEL === 0) {
                    this.levelUp();
                }

                this.spawnFood();
                this.updateUI();
            }

            levelUp() {
                this.level++;
                this.screenFlash = 15;
                this.generateLevel();

                // Make sure snake doesn't spawn inside new obstacles
                this.obstacles = this.obstacles.filter(obstacle => {
                    return !obstacle.some(o =>
                        this.snake.some(s => s.x === o.x && s.y === o.y)
                    );
                });
            }

            createParticles(x, y, color, count) {
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 * i) / count + Math.random() * 0.5;
                    const speed = Math.random() * 3 + 2;
                    this.particles.push({
                        x, y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed - 2,
                        color,
                        size: Math.random() * 4 + 2,
                        life: 1
                    });
                }
            }

            updateUI() {
                this.scoreDisplay.textContent = this.score;
                this.levelDisplay.textContent = `LEVEL ${this.level}`;
                this.comboMultiplier.textContent = `${this.combo}x`;

                // Color based on combo
                const colors = ['#ffffff', '#ffff00', '#ffaa00', '#ff6600', '#ff0000'];
                this.comboMultiplier.style.color = colors[this.combo - 1];
            }

            updateHighScoreDisplay() {
                this.highScoreDisplay.textContent = `HIGH: ${this.highScore}`;
                this.highScoreOverlay.textContent = `HIGH SCORE: ${this.highScore}`;
            }

            render() {
                const ctx = this.ctx;

                // Apply screen shake
                ctx.save();
                if (this.screenShake > 0) {
                    const shakeX = (Math.random() - 0.5) * this.screenShake;
                    const shakeY = (Math.random() - 0.5) * this.screenShake;
                    ctx.translate(shakeX, shakeY);
                    this.screenShake *= 0.9;
                }

                // Clear and draw background
                const gradient = ctx.createRadialGradient(
                    this.canvas.width / 2, this.canvas.height / 2, 0,
                    this.canvas.width / 2, this.canvas.height / 2, this.canvas.width
                );
                gradient.addColorStop(0, '#1a1f4a');
                gradient.addColorStop(1, '#0a0e27');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw stars
                this.stars.forEach(star => {
                    const twinkle = Math.sin(Date.now() * star.twinkleSpeed) * 0.3 + 0.7;
                    ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness * twinkle})`;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Draw shooting stars
                this.shootingStars.forEach(star => {
                    ctx.strokeStyle = `rgba(255, 255, 255, ${star.life})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(star.x, star.y);
                    ctx.lineTo(star.x - star.vx * 10, star.y - star.vy * 10);
                    ctx.stroke();
                });

                // Draw grid (subtle)
                ctx.strokeStyle = 'rgba(0, 217, 255, 0.05)';
                ctx.lineWidth = 1;
                for (let i = 0; i <= CONFIG.GRID_SIZE; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * CONFIG.CELL_SIZE, 0);
                    ctx.lineTo(i * CONFIG.CELL_SIZE, this.canvas.height);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, i * CONFIG.CELL_SIZE);
                    ctx.lineTo(this.canvas.width, i * CONFIG.CELL_SIZE);
                    ctx.stroke();
                }

                // Draw obstacles
                this.obstacles.forEach(obstacle => {
                    obstacle.forEach(o => {
                        const x = o.x * CONFIG.CELL_SIZE;
                        const y = o.y * CONFIG.CELL_SIZE;

                        ctx.fillStyle = '#4a4a5c';
                        ctx.fillRect(x + 2, y + 2, CONFIG.CELL_SIZE - 4, CONFIG.CELL_SIZE - 4);

                        // Rocky texture
                        ctx.fillStyle = '#3a3a4c';
                        for (let i = 0; i < 3; i++) {
                            const rx = x + 5 + Math.random() * 15;
                            const ry = y + 5 + Math.random() * 15;
                            ctx.beginPath();
                            ctx.arc(rx, ry, 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    });
                });

                // Draw portals
                this.portals.forEach(portal => {
                    this.drawPortal(portal.a, portal.color[0], portal.rotation);
                    this.drawPortal(portal.b, portal.color[1], portal.rotation);
                });

                // Draw food
                if (this.food) {
                    const fx = this.food.x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2;
                    const fy = this.food.y * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2;
                    const pulse = Math.sin(this.foodPulse) * 3;

                    // Glow
                    const glow = ctx.createRadialGradient(fx, fy, 0, fx, fy, 20 + pulse);
                    glow.addColorStop(0, 'rgba(255, 215, 0, 0.5)');
                    glow.addColorStop(1, 'rgba(255, 215, 0, 0)');
                    ctx.fillStyle = glow;
                    ctx.beginPath();
                    ctx.arc(fx, fy, 20 + pulse, 0, Math.PI * 2);
                    ctx.fill();

                    // Star shape
                    ctx.fillStyle = '#ffd700';
                    this.drawStar(fx, fy, 5, 10 + pulse / 2, 5);
                }

                // Draw snake
                this.snake.forEach((segment, index) => {
                    const x = segment.x * CONFIG.CELL_SIZE;
                    const y = segment.y * CONFIG.CELL_SIZE;
                    const isHead = index === 0;

                    // Calculate gradient color based on position
                    const t = index / Math.max(this.snake.length - 1, 1);
                    const r = Math.floor(0 + t * 0);
                    const g = Math.floor(217 - t * 80);
                    const b = Math.floor(255 - t * 119);

                    // Glow effect
                    if (isHead) {
                        const glow = ctx.createRadialGradient(
                            x + CONFIG.CELL_SIZE / 2, y + CONFIG.CELL_SIZE / 2, 0,
                            x + CONFIG.CELL_SIZE / 2, y + CONFIG.CELL_SIZE / 2, CONFIG.CELL_SIZE
                        );
                        glow.addColorStop(0, 'rgba(0, 217, 255, 0.3)');
                        glow.addColorStop(1, 'rgba(0, 217, 255, 0)');
                        ctx.fillStyle = glow;
                        ctx.beginPath();
                        ctx.arc(x + CONFIG.CELL_SIZE / 2, y + CONFIG.CELL_SIZE / 2, CONFIG.CELL_SIZE, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Body segment
                    const size = isHead ? CONFIG.CELL_SIZE - 4 : CONFIG.CELL_SIZE - 6;
                    const offset = isHead ? 2 : 3;

                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.beginPath();
                    ctx.roundRect(x + offset, y + offset, size, size, 5);
                    ctx.fill();

                    // Rim lighting
                    ctx.strokeStyle = `rgba(255, 255, 255, ${0.3 - t * 0.2})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Eyes on head
                    if (isHead) {
                        ctx.fillStyle = '#fff';
                        const eyeOffset = 6;
                        let eye1x, eye1y, eye2x, eye2y;

                        if (this.direction === Direction.RIGHT) {
                            eye1x = x + CONFIG.CELL_SIZE - 10; eye1y = y + 8;
                            eye2x = x + CONFIG.CELL_SIZE - 10; eye2y = y + CONFIG.CELL_SIZE - 12;
                        } else if (this.direction === Direction.LEFT) {
                            eye1x = x + 6; eye1y = y + 8;
                            eye2x = x + 6; eye2y = y + CONFIG.CELL_SIZE - 12;
                        } else if (this.direction === Direction.UP) {
                            eye1x = x + 8; eye1y = y + 6;
                            eye2x = x + CONFIG.CELL_SIZE - 12; eye2y = y + 6;
                        } else {
                            eye1x = x + 8; eye1y = y + CONFIG.CELL_SIZE - 10;
                            eye2x = x + CONFIG.CELL_SIZE - 12; eye2y = y + CONFIG.CELL_SIZE - 10;
                        }

                        ctx.beginPath();
                        ctx.arc(eye1x, eye1y, 3, 0, Math.PI * 2);
                        ctx.arc(eye2x, eye2y, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });

                // Draw trail effect at high combos
                if (this.combo >= 3 && this.snake.length > 1) {
                    ctx.strokeStyle = `rgba(0, 217, 255, ${0.1 * this.combo})`;
                    ctx.lineWidth = CONFIG.CELL_SIZE / 2;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(
                        this.snake[0].x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2,
                        this.snake[0].y * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2
                    );
                    for (let i = 1; i < Math.min(this.snake.length, 5); i++) {
                        ctx.lineTo(
                            this.snake[i].x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2,
                            this.snake[i].y * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2
                        );
                    }
                    ctx.stroke();
                }

                // Draw particles
                this.particles.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;

                // Screen flash
                if (this.screenFlash > 0) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${this.screenFlash / 30})`;
                    ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    this.screenFlash--;
                }

                // Update combo timer bar
                const timerPercent = Math.max(0, this.comboTimer / CONFIG.COMBO_TIMEOUT * 100);
                this.comboTimerFill.style.width = `${timerPercent}%`;

                // Pause overlay
                if (this.state === GameState.PAUSED) {
                    ctx.fillStyle = 'rgba(10, 14, 39, 0.8)';
                    ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 48px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('PAUSED', this.canvas.width / 2, this.canvas.height / 2);
                    ctx.font = '24px sans-serif';
                    ctx.fillText('Press SPACE to resume', this.canvas.width / 2, this.canvas.height / 2 + 40);
                }

                ctx.restore();
            }

            drawPortal(pos, color, rotation) {
                const x = pos.x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2;
                const y = pos.y * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2;
                const radius = CONFIG.CELL_SIZE / 2 - 2;

                // Outer glow
                const glow = this.ctx.createRadialGradient(x, y, radius * 0.5, x, y, radius * 2);
                glow.addColorStop(0, color);
                glow.addColorStop(0.5, color + '80');
                glow.addColorStop(1, color + '00');
                this.ctx.fillStyle = glow;
                this.ctx.beginPath();
                this.ctx.arc(x, y, radius * 2, 0, Math.PI * 2);
                this.ctx.fill();

                // Swirl effect
                this.ctx.save();
                this.ctx.translate(x, y);
                this.ctx.rotate(rotation);

                for (let i = 0; i < 3; i++) {
                    this.ctx.rotate(Math.PI * 2 / 3);
                    this.ctx.strokeStyle = color;
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, radius * 0.7, 0, Math.PI * 0.8);
                    this.ctx.stroke();
                }

                this.ctx.restore();

                // Center
                this.ctx.fillStyle = color;
                this.ctx.beginPath();
                this.ctx.arc(x, y, radius * 0.3, 0, Math.PI * 2);
                this.ctx.fill();

                // Shape indicator for colorblind accessibility
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                if (color === PORTAL_COLORS[0][0] || color === PORTAL_COLORS[0][1]) {
                    // Circle
                    this.ctx.arc(x, y, 5, 0, Math.PI * 2);
                } else if (color === PORTAL_COLORS[1][0] || color === PORTAL_COLORS[1][1]) {
                    // Square
                    this.ctx.rect(x - 4, y - 4, 8, 8);
                } else {
                    // Triangle
                    this.ctx.moveTo(x, y - 5);
                    this.ctx.lineTo(x + 5, y + 4);
                    this.ctx.lineTo(x - 5, y + 4);
                    this.ctx.closePath();
                }
                this.ctx.stroke();
            }

            drawStar(cx, cy, spikes, outerRadius, innerRadius) {
                let rot = Math.PI / 2 * 3;
                let x = cx;
                let y = cy;
                const step = Math.PI / spikes;

                this.ctx.beginPath();
                this.ctx.moveTo(cx, cy - outerRadius);

                for (let i = 0; i < spikes; i++) {
                    x = cx + Math.cos(rot) * outerRadius;
                    y = cy + Math.sin(rot) * outerRadius;
                    this.ctx.lineTo(x, y);
                    rot += step;

                    x = cx + Math.cos(rot) * innerRadius;
                    y = cy + Math.sin(rot) * innerRadius;
                    this.ctx.lineTo(x, y);
                    rot += step;
                }

                this.ctx.lineTo(cx, cy - outerRadius);
                this.ctx.closePath();
                this.ctx.fill();
            }

            gameLoop() {
                let lastTime = 0;

                const loop = (timestamp) => {
                    const deltaTime = timestamp - lastTime;
                    lastTime = timestamp;

                    this.update(deltaTime);
                    this.render();

                    requestAnimationFrame(loop);
                };

                requestAnimationFrame(loop);
            }
        }

        // Start the game
        new Game();
    </script>
</body>
</html>
